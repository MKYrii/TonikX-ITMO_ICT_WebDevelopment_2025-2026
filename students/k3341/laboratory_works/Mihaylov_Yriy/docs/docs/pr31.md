# Практическая работа 3.1. Django Web framework. Запросы и их выполнение.


## Цель работы

1. Создать и заполнить базу данных о автовладельцах, автомобилях, водительских удостоверениях и фактах владения.
2. Научиться выполнять выборку и фильтрацию данных с помощью Django ORM.
3. Освоить агрегирующие запросы (`Min`, `Max`, `Count`) и аннотирование (`annotate`).

---

## Модели данных

Использовались следующие модели (файл `owners/models.py`):

```
class CarOwner(models.Model):
    last_name = models.CharField(max_length=30)
    first_name = models.CharField(max_length=30)
    date_of_birth = models.DateTimeField(null=True, blank=True)

    cars = models.ManyToManyField(
        'Car',
        through='Ownership',
        related_name='owners'  # <-- по машине получаем всех владельцев
    )


class DriverLicense(models.Model):
    owner = models.ForeignKey(
        CarOwner,
        on_delete=models.CASCADE,
        related_name='licenses'  # <-- по владельцу: owner.licenses.all()
    )
    license_number = models.CharField(max_length=10)
    license_type = models.CharField(max_length=10)
    issue_date = models.DateTimeField()


class Car(models.Model):
    state_number = models.CharField(max_length=15)
    brand = models.CharField(max_length=20)
    model = models.CharField(max_length=20)
    color = models.CharField(max_length=30, null=True, blank=True)


class Ownership(models.Model):
    owner = models.ForeignKey(
        CarOwner,
        on_delete=models.CASCADE,
        related_name='ownerships'   # owner.ownerships.all()
    )
    car = models.ForeignKey(
        Car,
        on_delete=models.CASCADE,
        related_name='ownerships'   # car.ownerships.all()
    )
    start_date = models.DateTimeField()
    end_date = models.DateTimeField(null=True, blank=True)
```

## Заполнение базы данных значениями

Для заполнения базы был создан отдельный файл `311.py`.

Он запускается командой:

```
>>> python 311.py
```

Результатом запуска скрипта стало создание 6 владельцев, 6 автомобилей, 6 удостоверений и записей о владении, а также вывод на экран информации о каждом владельце и его машинах.

## Запросы на фильтрацию

Далее были реализованы запросы по условию задачи.
Все примеры вынесены в файл `312.py`

Содержимое файла:

```
import os
import django

# Установить настройки Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'car_project.settings')
django.setup()

from owners.models import CarOwner, Car, DriverLicense, Ownership


def print_header(title):
    print('\n' + '=' * 10, title, '=' * 10)


def run_queries():
    # 1. Все машины марки "Nissan"
    print_header('1. Все машины марки "Nissan"')
    nissans = Car.objects.filter(brand='Nissan')
    for car in nissans:
        print(f'{car.id}: {car.state_number} — {car.brand} {car.model} ({car.color})')

    # 2. Все водители с именем "Elena"
    print_header('2. Все водители с именем "Elena"')
    elenas = CarOwner.objects.filter(first_name='Elena')
    for owner in elenas:
        print(f'{owner.id}: {owner.last_name} {owner.first_name}')

    # 3. Взять любого владельца, получить его id и по нему удостоверение
    print_header('3. Случайный владелец и его удостоверение')
    owner = CarOwner.objects.first()
    if owner is None:
        print('В базе нет ни одного владельца.')
    else:
        print(f'Владелец: id={owner.id}, {owner.last_name} {owner.first_name}')
        try:
            # Получение удостоверения по owner_id
            license_obj = DriverLicense.objects.get(owner_id=owner.id)
            print(f'Удостоверение: {license_obj.license_number}, '
                  f'тип {license_obj.license_type}, '
                  f'дата выдачи {license_obj.issue_date}')
        except DriverLicense.DoesNotExist:
            print('У этого владельца нет удостоверения.')

    # 4. Найти всех владельцев красных машин (у нас красная Mazda CX-5)
    print_header('4. Владельцы красных машин (color="red")')
    red_owners = CarOwner.objects.filter(cars__color='red').distinct()
    for owner in red_owners:
        print(f'{owner.id}: {owner.last_name} {owner.first_name}')

    # 5. Найти владельцев, начавших владеть машиной в 2019 году
    print_header('5. Владельцы, начавшие владение машиной в 2019 году')
    owners_2019 = CarOwner.objects.filter(
        ownerships__start_date__year=2019
    ).distinct()
    for owner in owners_2019:
        print(f'{owner.id}: {owner.last_name} {owner.first_name}')


run_queries()

```

В результате запуска был получен следующий вывод:

```
========== 1. Все машины марки "Nissan" ==========
1: X101XX77 — Nissan Altima (green)

========== 2. Все водители с именем "Elena" ==========
2: Mikhailova Elena

========== 3. Случайный владелец и его удостоверение ==========
Владелец: id=1, Novikov Alexey
Удостоверение: GG1111111, тип B, дата выдачи 2014-05-20 00:00:00+00:00

========== 4. Владельцы красных машин (color="red") ==========
4: Lebedev Igor

========== 5. Владельцы, начавшие владение машиной в 2019 году ==========
1: Novikov Alexey
3: Orlov Kirill
```

## Агрегирующие запросы и аннотации

Эти запросы вынесены в отдельный файл `313.py`, запускаемый через:

```
python 313.py
```

Содержимое файла:

```
import os
import django

# Установить настройки Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'car_project.settings')
django.setup()

from django.db.models import Min, Max, Count
from owners.models import CarOwner, Car, DriverLicense, Ownership


def run_aggregate_queries():

    # 1. Самое старшее водительское удостоверение
    print('1. Самое старшее водительское удостоверение')
    oldest_issue = DriverLicense.objects.aggregate(
        earliest=Min('issue_date')
    )['earliest']
    print('Самое старое удостоверение выдано:', oldest_issue)

    # 2. Самая поздняя дата начала владения машиной
    print('\n2. Самая поздняя дата начала владения машиной')
    latest_ownership = Ownership.objects.aggregate(
        latest=Max('start_date')
    )['latest']
    print('Самая поздняя дата начала владения:', latest_ownership)

    # 3. Количество машин у каждого водителя
    print('\n3. Количество машин у каждого владельца')
    owners_with_car_count = CarOwner.objects.annotate(
        car_count=Count('cars', distinct=True)
    )
    for owner in owners_with_car_count:
        print(f'{owner.id}: {owner.last_name} {owner.first_name} — {owner.car_count} шт.')

    # 4. Количество машин каждой марки
    print('\n4. Количество машин каждой марки')
    cars_per_brand = Car.objects.values('brand').annotate(
        count=Count('id')
    )
    for row in cars_per_brand:
        print(f'{row["brand"]}: {row["count"]} шт.')

    # 5. Сортировка владельцев по дате выдачи удостоверения
    print('\n5. Владельцы, отсортированные по дате выдачи удостоверения')
    owners_by_license_date = CarOwner.objects.annotate(
        first_license_date=Min('licenses__issue_date')
    ).order_by('first_license_date').distinct()

    for owner in owners_by_license_date:
        print(f'{owner.id}: {owner.last_name} {owner.first_name} — {owner.first_license_date}')


run_aggregate_queries()
```

В результате запуска был получен следующий вывод:

```
1. Самое старшее водительское удостоверение
Самое старое удостоверение выдано: 2009-11-01 00:00:00+00:00

2. Самая поздняя дата начала владения машиной
Самая поздняя дата начала владения: 2022-07-07 00:00:00+00:00

3. Количество машин у каждого владельца
1: Novikov Alexey — 2 шт.
2: Mikhailova Elena — 1 шт.
3: Orlov Kirill — 3 шт.
4: Lebedev Igor — 1 шт.
5: Belova Maria — 2 шт.
6: Morozov Viktor — 2 шт.

4. Количество машин каждой марки
Ford: 1 шт.
Mazda: 1 шт.
Mercedes: 1 шт.
Nissan: 1 шт.
Renault: 1 шт.
Volkswagen: 1 шт.

5. Владельцы, отсортированные по дате выдачи удостоверения
4: Lebedev Igor — 2009-11-01 00:00:00+00:00
3: Orlov Kirill — 2011-08-30 00:00:00+00:00
6: Morozov Viktor — 2012-10-12 00:00:00+00:00
1: Novikov Alexey — 2014-05-20 00:00:00+00:00
2: Mikhailova Elena — 2017-02-14 00:00:00+00:00
5: Belova Maria — 2019-03-03 00:00:00+00:00
```

## Вывод
В ходе практической работы было выполнено:
- Реализована модель данных для работы с автовладельцами, автомобилями, водительскими удостоверениями и владением автомобилями, в том числе ассоциативная сущность Ownership.
- С помощью отдельного скрипта база данных была заполнена тестовыми данными (6 владельцев, 6 автомобилей, 6 удостоверений и множество записей владения).
- Выполнены запросы на фильтрацию данных с использованием связей ForeignKey, ManyToManyField и related_name.
- Освоены агрегирующие операции (Min, Max, Count) и аннотирование результатов (annotate), а также сортировка и устранение дубликатов с помощью distinct().
- Получен практический опыт работы с Django ORM как с удобной и мощной надстройкой над SQL.