# Практическая работа 3.2. Django Web framework. Запросы и их выполнение.

## Цель работы

1. Освоить установку и базовую настройку Django и Django REST Framework.
2. Научиться описывать модели для предметной области.
3. Реализовать сериализатор для преобразования данных моделей в формат JSON.
4. Создать представление на основе `APIView`, возвращающее список объектов.
5. Настроить маршрутизацию (URLconf) и протестировать работоспособность API в браузере.

## Подготовка окружения

### Установка Django и Django REST Framework

```
pip install django
pip install djangorestframework
```

### Подключение приложения и Django Rest Framework

```
INSTALLED_APPS = [
    # стандартные приложения Django …
    'rest_framework',
    'warriors_app',
]
```

## Модели данных

Файл `warriors_app/models.py`:

```
class Profession(models.Model):
    title = models.CharField(max_length=120, verbose_name='Название')
    description = models.TextField(verbose_name='Описание')

    def __str__(self):
        return self.title

class Skill(models.Model):
    title = models.CharField(max_length=120, verbose_name='Наименование')

    def __str__(self):
        return self.title

class Warrior(models.Model):
    race_types = (
        ('s', 'student'),
        ('d', 'developer'),
        ('t', 'teamlead'),
    )
    race = models.CharField(max_length=1, choices=race_types, verbose_name='Расса')
    name = models.CharField(max_length=120, verbose_name='Имя')
    level = models.IntegerField(verbose_name='Уровень', default=0)

    skill = models.ManyToManyField(
        'Skill',
        verbose_name='Умения',
        through='SkillOfWarrior',
        related_name='warrior_skils'
    )

    profession = models.ForeignKey(
        'Profession',
        on_delete=models.CASCADE,
        verbose_name='Профессия',
        blank=True,
        null=True,
        related_name='warriors'
    )

    def __str__(self):
        return f'{self.name} (lvl {self.level})'


class SkillOfWarrior(models.Model):
    skill = models.ForeignKey('Skill', verbose_name='Умение', on_delete=models.CASCADE)
    warrior = models.ForeignKey('Warrior', verbose_name='Воин', on_delete=models.CASCADE)
    level = models.IntegerField(verbose_name='Уровень освоения умения')

    def __str__(self):
        return f'{self.warrior} - {self.skill} ({self.level})'
```

## Сериализаторы 

Мною был создан набор сериализаторов для всех операций с моделями:

* **`SkillSerializer` / `ProfessionSerializer`** – обычные ModelSerializer для чтения скиллов и профессий.
* **`WarriorSerializer`** – базовый сериализатор воина.
* **`SkillCreateSerializer` / `ProfessionCreateSerializer`** – простые сериализаторы для создания скилла/профессии из полей `title` (+ `description`).
* **`WarriorProfessionSerializer`** – воин + вложенный объект профессии, плюс поле `race` через `get_race_display()`.
* **`WarriorSkillSerializer`** – воин + список его скиллов (вложенные `SkillSerializer`), тоже с `race`.
* **`WarriorFullSerializer`** – полный вариант: воин сразу с профессией и всеми скиллами и с расой.

Код сериализаторов:

```
class SkillSerializer(serializers.ModelSerializer):
    class Meta:
        model = Skill
        fields = ["id", "title"]


class ProfessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Profession
        fields = ["id", "title", "description"]


class WarriorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Warrior
        fields = "__all__"

class SkillCreateSerializer(serializers.Serializer):
    title = serializers.CharField(max_length=120)

    def create(self, validated_data):
        return Skill.objects.create(**validated_data)


class ProfessionCreateSerializer(serializers.Serializer):
    title = serializers.CharField(max_length=120)
    description = serializers.CharField()

    def create(self, validated_data):
        return Profession.objects.create(**validated_data)

class WarriorProfessionSerializer(serializers.ModelSerializer):
    profession = ProfessionSerializer()
    race = serializers.CharField(source="get_race_display", read_only=True)

    class Meta:
        model = Warrior
        fields = "__all__"

class WarriorSkillSerializer(serializers.ModelSerializer):
    skill = SkillSerializer(many=True)
    race = serializers.CharField(source="get_race_display", read_only=True)

    class Meta:
        model = Warrior
        fields = "__all__"


class WarriorFullSerializer(serializers.ModelSerializer):
    profession = ProfessionSerializer()
    skill = SkillSerializer(many=True)
    race = serializers.CharField(source="get_race_display", read_only=True)

    class Meta:
        model = Warrior
        fields = "__all__"
```


## Представления на основе Apiview 

Был создан набор DRF-представлений:

* список/просмотр/редактирование воинов,
* создание и просмотр профессий и скиллов,
* отдельные эндпоинты, которые отдают воинов вместе с профессией или скиллами.


```
class WarriorAPIView(APIView):
    def get(self, request):
        warriors = Warrior.objects.all()
        serializer = WarriorSerializer(warriors, many=True)
        return Response({"Warriors": serializer.data})


class ProfessionCreateView(APIView):
    def post(self, request):
        profession = request.data.get("profession")
        serializer = ProfessionCreateSerializer(data=profession)

        if serializer.is_valid(raise_exception=True):
            profession_saved = serializer.save()

        return Response({"Success": f"Profession '{profession_saved.title}' created succesfully."})

class SkillListAPIView(APIView):
    def get(self, request):
        skills = Skill.objects.all()
        serializer = SkillSerializer(skills, many=True)
        return Response({"Skills": serializer.data})


class SkillCreateAPIView(APIView):
    def post(self, request):
        skill_data = request.data.get("skill")
        serializer = SkillCreateSerializer(data=skill_data)

        if serializer.is_valid(raise_exception=True):
            skill_saved = serializer.save()

        return Response({"Success": f"Skill '{skill_saved.title}' created succesfully."})

class WarriorProfessionListAPIView(generics.ListAPIView):
    serializer_class = WarriorProfessionSerializer

    def get_queryset(self):
        return Warrior.objects.select_related("profession").all()

class WarriorSkillListAPIView(generics.ListAPIView):
    serializer_class = WarriorSkillSerializer

    def get_queryset(self):
        return Warrior.objects.prefetch_related("skill").all()


class WarriorDetailAPIView(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = WarriorFullSerializer
    queryset = Warrior.objects.all()
    lookup_field = "pk"
```

## Запуск сервера и тестирование API

Необходимо создать суперюзера:

```
python manage.py createsuperuser
```

А затем запустить сервер:

```
python manage.py runserver
```

Далее необходимо перейти в браузер по адресу `http://127.0.0.1:8000/api/warriors/`.

## Выводы

В ходе работы мною был создан и настроен простой REST-сервис на Django REST Framework: описаны модели, сериализаторы и API-представления, настроены маршруты и получены работающие JSON-эндпоинты для просмотра и изменения данных о воинах, профессиях и навыках.

